基于2.0
https://github.com/supercj92/ssi-springmvc/blob/master/tbschedule.mdj
这个版本的tbschedule使用db作为注册中心
表共四张：
worker信息表
pamirs_schedule_server
pamirs_schedule_server_his
队列信息表
pamirs_schedule_queue
任务运行时监控表
pamirs_schedule_tasktrun
任务表
pamirs_schedule_tasktype
表的作用
pamirs_schedule_server
每一台worker启动后，都会往PAMIRS_SCHEDULE_SERVER注册自己，启动后并且会发送心跳信息，定时更新自己的记录。一条记录代表一个worker。
pamirs_schedule_server_his
worker心跳信息备份表，死亡的worker会转移到这张表中
pamirs_schedule_tasktype
任务配置信息表。配置任务的心跳间隔时间、每次任务抓取数量、指定处理任务的bean等
pamirs_schedule_queue
CUR_SERVER：当前持有队列的机器id
REQ_SERVER：想要持有队列的机器id
当前机器和队列的映射关系。机器和队列的关系可能为，一对一，一对多
重新分配队列
如果有机器挂掉，则需要重新分配任务。怎么判断机器挂掉呢？看pamirs_schedule_server表，机器的心跳时间与当前时间差值大于死亡间隔。死亡间隔用来判断机器隔多久没更新心跳，则可以判断机器挂了。
如果队列数与机器数相等，则队列与机器一一对应。
如果队列数大于机器数，则一个机器可能对应多个队列，保证每个队列都有机器。两个队列可能对应同一台机器。
如果队列数小于机器数，则一个队列对应唯一一台机器，机器有剩余，有的机器没有分配到队列。
根据cron表达式开始任务
拿到cron字符串后，使用CronExpression工具，计算下一次运行的时间，使用Timer.schedule(TimerTask task, Date time)方法，设置在指定time时间点执行task。
开始处理任务
com.taobao.pamirs.schedule.TBScheduleManager.resume
定时任务
使用Timer，建立TimerTask，来进行定时调度。框架实现了两个任务。
PauseOrResumeScheduleTask：在cron表达式设置的时间定时执行或暂停任务
HeartBeatTimerTask：定时发送心跳包，更新当前worker的心跳时间
关键组件
IScheduleTaskDeal：业务实现。体用三个方法。一个是获取处理数据的方法，第二个是处理数据的方法，第三个是在NotSleep模式进行数据对比的方法
IScheduleProcessor：任务调度器。有两种实现，一种是Sleep模式实现，一种是NotSleep模式实现。
Sleep模式任务调度器
根据IScheduleTaskDeal.selectTasks获取要处理的数据。处理任务分为两种，一种一次处理一条，一种是一次处理一批。根据处理任务类型，获取指定数量的数据，调用IScheduleTaskDeal.execute()方法，按照业务逻辑处理指定数据集。
NotSleep模式任务调度器
数据重复的问题
不睡眠模式有一个问题，当一个线程（A线程）从当前任务队列拿不到数据时，就去装载数据。这个时候，其他线程还有正在处理的数据。而A线程装载的数据和其他线程正在处理的数据可能会有重复的。例如、一条数据data1，已经在线程B的处理队列中，data1等待被处理，此时它的状态是未处理。A线程装载数据时，是可能把data1重现装载进来的。如果处理了两边就有问题。
解决办法
保存当前正在处理的任务，当从线程共享的队列中获取任务时，检查此任务是否在正在处理的任务列表中。如果是则丢弃，取下一条数据。
涉及的多线程处理
这个过程是多线程处理的，开启多个线程，具体线程数是任务配置的。IScheduleTaskDeal.selectTasks的任务是多个线程共享的，多个线程处理数据集。涉及线程之间的通信。线程间获取任务时要加锁，当任务出完毕后，即共享数据集size为0时，线程进入等待状态。最后一根线程，重新装载业务数据，如果有数据，则唤醒等待的线程进行处理。如果没获取到，则sleep固定时间，然后再尝试。
基于3.0